<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Business Case 5 | GANESH NAIK </title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-bg: #141414;
            --color-text: #ffffff;
            --color-accent: #e50914;
            --color-highlight: #b3b3b3;
            --color-muted: #737373;
            --color-shadow: rgba(0, 0, 0, 0.3);
            --primary-shade: #b20710;
            --border-radius: 4px;
            --section-bg: #1f1f1f;
            --project-bg: #252525;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            scroll-behavior: smooth;
            font-family: 'Helvetica Neue', Arial, sans-serif;
        }

        body {
            background: var(--color-bg);
            color: var(--color-text);
            line-height: 1.5;
            padding-top: 70px;
        }

        .navbar {
            position: fixed;
            top: 0;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            height: 70px;
            display: flex;
            align-items: center;
        }

        .nav-container {
            max-width: 1370px;
            margin: 0 auto;
            padding: 0 4%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .nav-logo {
            font-weight: 700;
            font-size: 1.5rem;
            color: var(--color-accent);
            text-transform: uppercase;
        }

        .section {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            padding: 3rem 4%;
            max-width: 1370px;
            margin: auto;
            min-height: calc(100vh - 70px);
            background: linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url('https://i.pinimg.com/originals/19/8b/2f/198b2f01e73b905772279616eccc7c65.jpg');
            background-size: cover;
            background-position: center;
        }

        h2 {
            color: var(--color-text);
            margin-bottom: 1.5rem;
            font-size: 1.8rem;
            font-weight: 500;
            text-align: left;
        }

        .business-case-item {
            background-color: var(--project-bg);
            padding: 1.5rem;
            border-radius: var(--border-radius);
            border: 1px solid #333;
            transition: transform 0.3s ease;
        }

        .business-case-item:hover {
            transform: scale(1.02);
        }

        .business-case-title {
            color: var(--color-accent);
            font-size: 1.5rem;
            margin-bottom: 0.75rem;
        }

        .business-case-desc {
            color: var(--color-highlight);
            font-size: 1rem;
            line-height: 1.6;
            margin-bottom: 1rem;
        }

        .business-case-item img {
            max-width: 100%;
            height: auto;
            display: block;
            margin-bottom: 1rem;
            border-radius: var(--border-radius);
        }

        .business-case-desc pre {
            background-color: #1a1a1a;
            padding: 1rem;
            border-radius: var(--border-radius);
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            color: #ffffff;
            white-space: pre-wrap;
        }

        .business-case-desc code {
            font-family: 'Courier New', Courier, monospace;
        }

        .nav-arrows {
            display: flex;
            justify-content: space-between;
            padding: 1rem 4%;
            max-width: 1370px;
            margin: 2rem auto;
            background: var(--color-bg);
        }

        .nav-arrow {
            background-color: var(--color-accent);
            color: var(--color-text);
            padding: 0.5rem 1rem;
            border-radius: var(--border-radius);
            text-decoration: none;
            font-size: 0.9rem;
            transition: background-color 0.3s ease;
        }

        .nav-arrow:hover {
            background-color: var(--primary-shade);
        }

        /* Added styles for the Watch Now button */
        .watch-now-button {
            background-color: var(--color-accent);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 16px;
            margin: 10px 0;
            transition: background-color 0.3s ease;
        }
        
        .watch-now-button:hover {
            background-color: var(--primary-shade);
        }
        
        .hidden-code {
            display: none;
            background-color: #1a1a1a;
            border: 1px solid #333;
            padding: 15px;
            border-radius: var(--border-radius);
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre;
        }

        @media (max-width: 767px) {
            .section {
                padding: 2rem 1rem;
            }
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo"> GANESH NAIK </div>
        </div>
    </nav>

    <main class="section">
        <h2>Moments Feature with Bookmarking</h2>
        <div class="business-case-item">
            <h3 class="business-case-title">What is the Feature About?</h3>
            <img src="images/moments.jpg" alt="Moments Bookmarking GIF">
            <p class="business-case-desc">Imagine watching Sacred Games and wanting to revisit Nawazuddin Siddiqui’s iconic scene later. Netflix’s Moments feature lets you bookmark specific scenes in shows or movies, like that heart-pounding chase in Money Heist or a tearjerker moment in Panchayat. It’s not just a bookmark, it’s a time machine that takes you back to your favorite moments instantly, enhancing your viewing experience with precision and ease.</p>
        </div>
        <div class="business-case-item">
            <h3 class="business-case-title">Why This Matters?</h3>
            <p class="business-case-desc">This feature is Netflix’s way of making every scene unforgettable. By allowing users to save and replay moments, it deepens engagement, letting you relive Mirzapur’s intense showdowns or Crash Landing on You*’s romantic highs. It’s perfect for sharing clips with friends or revisiting key plot points. In India, where 70% of viewers rewatch favorite scenes, this feature boosts user satisfaction, encourages longer sessions, and strengthens Netflix’s edge in a competitive streaming market, keeping subscribers hooked.</p>
        </div>
        <div class="business-case-item">
            <h3 class="business-case-title">Actors Behind the Scenes</h3>
            <p class="business-case-desc">The Moments feature is powered by a B-Tree, a self-balancing tree that stores bookmarks indexed by user ID and timestamp. Each node holds multiple bookmarks, like a user’s saved scene from Delhi Crime at 23:45, ensuring fast insertion and retrieval. The B-Tree keeps bookmarks sorted, so Netflix can quickly fetch all moments for a user or a specific title, making your saved scenes just a click away.</p>
            <button class="watch-now-button" onclick="toggleCode('bTreeCode')">Watch now</button>
            <div id="bTreeCode" class="hidden-code">
class BTreeNode:
    def __init__(self, t, leaf=True):
        self.t = t  # Minimum degree
        self.leaf = leaf
        self.keys = []  # List of (user_id, timestamp, moment_id)
        self.children = []
    
class BTree:
    def __init__(self, t):
        self.root = BTreeNode(t)
        self.t = t
    
    def insert(self, key):
        root = self.root
        if len(root.keys) == (2 * self.t) - 1:
            new_root = BTreeNode(self.t, False)
            new_root.children.append(root)
            self._split_child(new_root, 0)
            self.root = new_root
        self._insert_non_full(self.root, key)
    
    def _split_child(self, parent, i):
        t = self.t
        y = parent.children[i]
        z = BTreeNode(t, y.leaf)
        parent.children.insert(i + 1, z)
        parent.keys.insert(i, y.keys[t - 1])
        z.keys = y.keys[t:]
        y.keys = y.keys[:t - 1]
        if not y.leaf:
            z.children = y.children[t:]
            y.children = y.children[:t]
    
    def _insert_non_full(self, node, key):
        i = len(node.keys) - 1
        if node.leaf:
            node.keys.append(None)
            while i >= 0 and key < node.keys[i]:
                node.keys[i + 1] = node.keys[i]
                i -= 1
            node.keys[i + 1] = key
        else:
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1
            if len(node.children[i].keys) == (2 * self.t) - 1:
                self._split_child(node, i)
                if key > node.keys[i]:
                    i += 1
            self._insert_non_full(node.children[i], key)
    
    def search(self, key):
        return self._search_rec(self.root, key)
    
    def _search_rec(self, node, key):
        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1
        if i < len(node.keys) and key == node.keys[i]:
            return node.keys[i]
        if node.leaf:
            return None
        return self._search_rec(node.children[i], key)

# Example: Managing bookmarks
btree = BTree(t=2)
btree.insert(("user123", 23.45, "MH001_23.45"))
btree.insert(("user123", 45.12, "DC001_45.12"))
moment = btree.search(("user123", 23.45))
print("Found moment:", moment)
            </div>
        </div>
        <div class="business-case-item">
            <h3 class="business-case-title">Visualization (Models and Figures)</h3>
            <p class="business-case-desc">Picture the B-Tree as a filing cabinet for your bookmarked moments. Each drawer (node) holds multiple bookmarks, like your saved scene from Heeramandi at 15:30 or Stranger Things at 32:10, sorted by user ID and timestamp. The tree’s balanced structure ensures quick access, even with millions of bookmarks. When you revisit a moment, Netflix queries the B-Tree, retrieves the timestamp, and serves the scene via an API, with Redis caching frequent bookmarks for instant playback.</p>
        </div>
        <div class="business-case-item">
            <h3 class="business-case-title">Efficiency Analysis</h3>
            <p class="business-case-desc">The B-Tree is a performance beast for bookmarking. Inserting a bookmark takes O(log n) time, where n is the number of bookmarks, thanks to its balanced structure. Searching for a moment is also O(log n), ensuring quick retrieval. Space complexity is O(n) to store the tree, which scales well for Netflix’s millions of users. Caching popular bookmarks in Redis drops query time to O(1), perfect for India’s mobile users who expect instant scene replays. The trade-off is occasional rebalancing during insertions, but B-Trees minimize this overhead, keeping the system nimble.</p>
        </div>
        <div class="business-case-item">
            <h3 class="business-case-title">Alternative Data Structures to B-Tree</h3>
            <p class="business-case-desc">B-Trees are the go to for bookmark management, but what if they weren’t available? Let’s explore four alternatives: Red-Black Tree, AVL Tree, Hash Table, and Skip List, and why B-Trees remain the top choice.</p>
        </div>
        <div class="business-case-item">
            <h3 class="business-case-title">1) Red-Black Tree</h3>
            <p class="business-case-desc">Description: A self-balancing binary search tree with color properties to ensure balance. <br> Complexity: Insert/Search: O(log n); Space: O(n). <br> Drawback: Stores only one key per node, leading to deeper trees and more memory overhead than B-Trees for large datasets. <br>
            <button class="watch-now-button" onclick="toggleCode('redBlackTreeCode')">Watch now</button>
            <div id="redBlackTreeCode" class="hidden-code">
class RBNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.color = 'RED'

class RedBlackTree:
    def __init__(self):
        self.root = None
    
    def insert(self, key):
        # Insert and balance
        pass
    
    def search(self, key):
        # Search logic
        pass
            </div>
            </p>
        </div>
        <div class="business-case-item">
            <h3 class="business-case-title">2) AVL Tree</h3>
            <p class="business-case-desc">Description: A self-balancing binary search tree with height balance enforced. <br> Complexity: Insert/Search: O(log n); Space: O(n). <br> Drawback: Strict balancing increases rotation overhead, and single-key nodes are less efficient than B-Trees’ multi-key nodes. <br>
            <button class="watch-now-button" onclick="toggleCode('avlTreeCode')">Watch now</button>
            <div id="avlTreeCode" class="hidden-code">
class AVLNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1

class AVLTree:
    def __init__(self):
        self.root = None
    
    def insert(self, key):
        # Insert and balance
        pass
    
    def search(self, key):
        # Search logic
        pass
            </div>
            </p>
        </div>
        <div class="business-case-item">
            <h3 class="business-case-title">3) Hash Table</h3>
            <p class="business-case-desc">Description: Maps user ID and timestamp to moment IDs using a hash function. <br> Complexity: Insert/Search: O(1) average; Space: O(n). <br> Drawback: Lacks range queries (e.g., all moments for a user), and hash collisions can degrade performance for Netflix’s scale. <br>
            <button class="watch-now-button" onclick="toggleCode('hashTableCode')">Watch now</button>
            <div id="hashTableCode" class="hidden-code">
class HashTable:
    def __init__(self):
        self.table = {}
    
    def insert(self, key, value):
        self.table[key] = value
    
    def search(self, key):
        return self.table.get(key)
    
# Example
hashtable = HashTable()
hashtable.insert(("user123", 23.45), "MH001_23.45")
            </div>
            </p>
        </div>
        <div class="business-case-item">
            <h3 class="business-case-title">4) Skip List</h3>
            <p class="business-case-desc">Description: A probabilistic layered linked list for sorted data access. <br> Complexity: Insert/Search: O(log n) average; Space: O(n log n). <br> Drawback: Higher space overhead and probabilistic performance make it less reliable than B-Trees for Netflix’s deterministic needs. <br>
            <button class="watch-now-button" onclick="toggleCode('skipListCode')">Watch now</button>
            <div id="skipListCode" class="hidden-code">
class SkipListNode:
    def __init__(self, key, value, level):
        self.key = key
        self.value = value
        self.forward = [None] * (level + 1)

class SkipList:
    def __init__(self):
        self.head = SkipListNode(None, None, 10)
    
    def insert(self, key, value):
        # Insert logic
        pass
    
    def search(self, key):
        # Search logic
        pass
            </div>
            </p>
        </div>
        <div class="business-case-item">
            <h3 class="business-case-title">Why B-Tree is Better?</h3>
            <p class="business-case-desc"> -> Efficiency: B-Trees offer O(log n) for insert/search with fewer disk I/O operations due to multi-key nodes, outperforming Red-Black and AVL Trees’ deeper structures.<br>
-> Range Queries: B-Trees support efficient range queries (e.g., all user moments), unlike Hash Tables, which lack ordering.<br>
-> Simplicity: B-Trees are more deterministic than Skip Lists’ probabilistic nature and easier to optimize for Netflix’s scale than binary trees.<br>
-> Scalability: With Redis caching, B-Trees handle millions of bookmarks, delivering instant moment replays to users worldwide.</p>
        </div>
        <div class="business-case-item">
            <h3 class="business-case-title">Learnings</h3>
            <p class="business-case-desc">B-Trees’ fast access (O(log n)) ensures instant moment replays, keeping users engaged with scenes like Vincenzo’s climactic fights.<br>
Supporting scene bookmarking taps into India’s 70% rewatch culture, boosting user loyalty and subscriptions.<br>
Redis caching delivers seamless moment access, crucial for India’s 80% mobile traffic, ensuring a smooth experience.<br>
The B-Tree scales with Netflix’s growing user base and catalog, including originals like Mismatched, keeping bookmarks robust.<br>
Periodic rebalancing adapts to new bookmarks, maintaining performance during peak viewing hours.</p>
        </div>
    </main>

    <div class="nav-arrows">
        <a href="business-case4.html" class="nav-arrow">← Previous</a>
        <a href="index.html" class="nav-arrow">X Close Business Case </a>
        <a href="business-case6.html" class="nav-arrow">Next →</a>
    </div>

    <script>
        function toggleCode(id) {
            var code = document.getElementById(id);
            if (code.style.display === "block") {
                code.style.display = "none";
            } else {
                code.style.display = "block";
            }
        }
    </script>
</body>
</html>
